<Icon style={styles.welcome} name='building' size={30}></Icon>
        <Button onPress={ ()=> clippingsStore.getFromRemote() }>
          Back
        </Button>

rn 对fb的编译需要在/Documents/FacebookSDK路径存在



export const isSignedIn = () => {
  return new Promise((resolve, reject) => {
    AsyncStorage.getItem(USER_KEY)
      .then(res => {
        if (res !== null) {
          resolve(true);
        } else {
          resolve(false);
        }
      })
      .catch(err => reject(err));
  });
};

this.refs.forminput.refs.email, this.refs.forminput.refs.pwd

export const isSignedInByFirebase = (email, password) => {
  return new Promise((resolve, reject) => {
    fb.auth().signInWithEmailAndPassword(email, password).then((result) => {
      console.log(result);
      resolve(true);
    }, (error) => {
      console.log(error);
      resolve(false);
    })
  });
};

export const createUserWithEmailAndPassword = (email, password) => {
  return new Promise((resolve, reject) => {
    fb.auth().createUserWithEmailAndPassword(email, password).then((result) => {
      console.log(result);
      resolve(true);
    }, (error) => {
      console.log(error);
      resolve(false);
    })
  });
};



        let {email, emailVerified, phoneNumber, photoURL, uid, refreshToken} = r;
        this.user = {email, emailVerified, phoneNumber, photoURL, uid, refreshToken};


        // Prepare Blob support
        import RNFetchBlob from 'react-native-fetch-blob';
        const Blob = RNFetchBlob.polyfill.Blob;
        const fs = RNFetchBlob.fs;
        window.XMLHttpRequest = RNFetchBlob.polyfill.XMLHttpRequest;
        window.Blob = Blob;

        const uploadImage = (response) => {
          return new Promise((resolve, reject) => {
            const uploadUri = Platform.OS === 'ios' ? response.uri.replace('file://', '') : response.uri
            //const sessionId = new Date().getTime()
            const sessionId = new Date().getTime()
            let uploadBlob = null
            const imageRef = storage.ref('images').child(`${response.fileName}`)
            let ext = response.fileName.split('.')[1].toLowerCase();
            var mime = "application/octet-stream";
            if(ext === "jpg") {
              mime = "image/jpg";
            } else if(ext === "png") {
              mime = "image/png";
            }
            fs.readFile(uploadUri, 'base64')
              .then((data) => {
                return Blob.build(data, { type: `${mime};BASE64` })
              })
              .then((blob) => {
                uploadBlob = blob
                return imageRef.put(blob, { contentType: mime })
              })
              .then(() => {
                uploadBlob.close()
                return imageRef.getDownloadURL()
              })
              .then((url) => {
                resolve(url)
              })
              .catch((error) => {
                reject(error)
              })
          })
        }

        import ImagePicker from 'react-native-image-picker';
        _pickImage() {
            this.setState({ uploadURL: '' })

            ImagePicker.launchImageLibrary({}, response  => {
              uploadImage(response)
                .then(url => this.setState({ uploadURL: url }))
                .catch(error => console.log(error))
            })
          }


          <ListView dataSource = {this.state.dataSource}
                          removeClippedSubviews={false}
                          renderRow={this._renderRow}
                          style = {styles.listview} />


    this.setState((previousState) => {
      return {
        messages: GiftedChat.append(previousState.messages, messages),
      };
    });


    <ListView refreshControl={
              <RefreshControl
                refreshing={clippingsStore.loading}
                onRefresh={() => clippingsStore.getFromRemote()}
              />
            }
              enableEmptySections={true}
              automaticallyAdjustContentInsets={true}
              initialListSize={1}
              dataSource={this.ds.cloneWithRows(clippingsStore.clippings.slice())}
              renderRow={this._renderRow}
              onEndReachedThreshold={1}
            />

    ds = new ListView.DataSource({
        rowHasChanged: (r1, r2) => {
          return r1 !== r2
        }
      });



    <View style={ styles.headerClose }>
              <Icon onPress={ Actions.pop } name="chevron-down" size={15} color="#fff" />
            </View>